# ScopeStorage
The idea of the Scoped Storage is to compartmentalize the storage into specified collections to limit the access to broad storage.

## Problems before Scope Storage
Before Android 10, we have a concept of Shared Storage. Every application in the device has some private storage in the internal memory and you can find this in android/data/your_package_name directory. Apart from this internal storage, the rest of the storage is called the Shared Storage i.e. every application with the storage permission can access this part of the memory. This includes media collections and other files of different applications. But the problem is that the application having the storage permission doesn't require the access of all of these files. All they want is to perform some small operation over some small part of the memory and that's it. For example, save and upload profile picture and nothing else. So, why to provide them with the full access to that Shared Storage and expose the users data?

Also, the second problem is because when an application having storage permissions, creates files or folders they get scattered all over user’s storage directory making it cluttered, and if the user decides to uninstall the app the files / folders that were created by the app still exist in that same location, unless you manually delete those files / folders once you’re done using them.


## Why Scope Storage
 it stops malicious apps that depend on the user for granting access to their sensitive data because they did not read what they saw in the dialog and just clicked on allow. It also allows a developer to have their own space on the storage of your device that is private without asking for any specific permissions and no other app can access any document it creates without user granting temporary permissions.

 system knows which file is generated by which application. The benefit of doing this is, you will have better management of files of a particular application. Also, when you uninstall an application from the device then all the contents related to the app will also be removed unless the user explicitly wants to keep it.
 
 As we know that the internal storage of the app is private and can't be accessed by other applications. But the external storage is accessed by applications with storage permission. With the help of Scoped Storage, the data in the external storage can not be easily accessed by other applications Since, Scope storage will become mandatory for the platforms after a year.
 
 <b>
 As per Google Play requirements, to provide users with the best Android experience possible, the Google Play Console will continue to require that apps target a recent API level. Apps will be required to use scoped storage in next year’s major platform release for all apps, independent of target SDK level. Therefore, you should ensure that your app works with scoped storage well in advance.
 </b>
 

### Is Scoped Storage required for all apps on Android 10?
No, it only applies when your targetSdkVersion is set to 29, so legacy apps continue to work. Also, even if you are targeting API 29 you can still use the legacy storage by setting ```android:requestLegacyExternalStorage=”true”``` on the application tag inside of AndroidManifest.xml.

### How to access simple files?
In order to access files on the device, you can use the Storage Access Framework (SAF). By using ```ACTION_OPEN_DOCUMENT``` a dialog will be shown to the user where the needed documents can be selected. There’s also ```ACTION_OPEN_DOCUMENT_TREE``` to ask the user to select a directory and ```ACTION_CREATE_DOCUMENT``` in order to save files.

# Repo Explained
## Creating file directory URI using FileProvider
To capture image we have to create external file directory using ```getExternalFilesDir(Environment.DIRECTORY_DCIM)``` and create uri from it.
There are other Environment as well, like  
```Environment.DIRECTORY_MUSIC```,     
```Environment.DIRECTORY_PODCASTS```,    
```Environment.DIRECTORY_RINGTONES```,    
```Environment.DIRECTORY_ALARMS```,   
```Environment.DIRECTORY_NOTIFICATIONS```,    
```Environment.DIRECTORY_PICTURES```, or   
```Environment.DIRECTORY_MOVIES```.   

The recommended way to share the content of a private file is using the ```FileProvider```.  

Following steps for create FileProvider:
1. Android Manifest
```xml
<application>
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileProvider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths"/>
        </provider>
    </application>
 ```
    
2. Specifying available files in ```provider_paths.xml```   
```xml
<?xml version="1.0" encoding="utf-8"?>
<paths>
    <external-cache-path
        name="external_cache_files"
        path="." />
    <external-files-path
        name="external_files_files"
        path="." />
    <external-path
        name="external_files"
        path="." />
</paths>
```

3. Generating content URI for a file  
```kotlin
val folder = File("${getExternalFilesDir(Environment.DIRECTORY_DCIM)}")
        folder.mkdirs()

        val file = File(folder, "Image_Tmp.jpg")
        if (file.exists())
            file.delete()
        file.createNewFile()
        imageUri = FileProvider.getUriForFile(
            this,
            BuildConfig.APPLICATION_ID + getString(R.string.file_provider_name),
            file
        )
        imgPath = file.absolutePath
        return imageUri!!
```

## Take a photo or Select Image from gallery  
```kotlin
 private fun chooseImage() {
        startActivityForResult(getPickImageIntent(), 100)
    }

    private fun getPickImageIntent(): Intent? {
        var chooserIntent: Intent? = null

        var intentList: MutableList<Intent> = ArrayList()

        val pickIntent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)

        val takePhotoIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
        takePhotoIntent.putExtra(MediaStore.EXTRA_OUTPUT, setImageUri())

        intentList = addIntentsToList(this, intentList, pickIntent)
        intentList = addIntentsToList(this, intentList, takePhotoIntent)

        if (intentList.size > 0) {
            chooserIntent = Intent.createChooser(
                intentList.removeAt(intentList.size - 1),
                getString(R.string.select_capture_image)
            )
            chooserIntent!!.putExtra(
                Intent.EXTRA_INITIAL_INTENTS,
                intentList.toTypedArray<Parcelable>()
            )
        }

        return chooserIntent
    }
```

## Read Bitmap from URI
In ```onActivityResult()``` intentData parameter contains URI if user selects image from gallery, otherwise data will be available in imageUri which we were created earlier.

```kotlin
@Throws(IOException::class)
private fun getBitmapFromUri(uri: Uri): Bitmap {
    val parcelFileDescriptor: ParcelFileDescriptor = contentResolver.openFileDescriptor(uri, "r")
    val fileDescriptor: FileDescriptor = parcelFileDescriptor.fileDescriptor
    val image: Bitmap = BitmapFactory.decodeFileDescriptor(fileDescriptor)
    parcelFileDescriptor.close()
    return image
}
```

